import
  os, options, strformat,
  confutils/defs, chronicles/options as chroniclesOptions,
  spec/[crypto, datatypes], time, version

export
  defs

type
  ValidatorKeyPath* = TypedInputFile[ValidatorPrivKey, Txt, "privkey"]

  StartUpCommand* = enum
    noCommand
    createChain
    importValidator
    updateTestnet

  Network* = enum
    ephemeralNetwork
    testnet0
    testnet1
    mainnet

  BeaconNodeConf* = object
    logLevel* {.
      desc: "Sets the log level",
      defaultValue: enabledLogLevel.}: LogLevel

    network* {.
      desc: "The network Nimbus should connect to"
      longform: "network"
      shortform: "n"
      defaultValue: testnet0.}: Network

    case cmd* {.
      command
      defaultValue: noCommand.}: StartUpCommand

    of noCommand:
      dataDir* {.
        desc: "The directory where nimbus will store all blockchain data."
        shortform: "d"
        defaultValue: config.defaultDataDir().}: OutDir

      bootstrapNodes* {.
        desc: "Specifies one or more bootstrap nodes to use when connecting to the network."
        longform: "bootstrapNode"
        shortform: "b".}: seq[string]

      bootstrapNodesFile* {.
        desc: "Specifies a line-delimited file of bootsrap Ethereum network addresses"
        shortform: "f"
        defaultValue: "".}: InputFile

      tcpPort* {.
        desc: "TCP listening port"
        defaultValue: config.defaultPort().}: int

      udpPort* {.
        desc: "UDP listening port",
        defaultValue: config.defaultPort().}: int

      nat* {.
        desc: "Specify method to use for determining public address. Must be one of: any, extip:<IP>"
        defaultValue: "any" .}: string

      validators* {.
        required
        desc: "Path to a validator private key, as generated by validator_keygen"
        longform: "validator"
        shortform: "v".}: seq[ValidatorKeyPath]

      stateSnapshot* {.
        desc: "Json file specifying a recent state snapshot"
        shortform: "s".}: Option[TypedInputFile[BeaconState, Json, "json"]]

    of createChain:
      validatorsDir* {.
        desc: "Directory containing validator descriptors named vXXXXXXX.deposit.json"
        shortform: "d".}: InputDir

      numValidators* {.
        desc: "The number of validators in the newly created chain".}: int

      firstValidator* {.
        desc: "index of first validator to add to validator list"
        defaultValue: 0.}: int

      genesisOffset* {.
        desc: "Seconds from now to add to genesis time"
        shortForm: "g"
        defaultValue: 5 .}: int

      outputStateFile* {.
        desc: "Output file where to write the initial state snapshot"
        longform: "out"
        shortform: "o".}: OutFile

    of importValidator:
      keyFile* {.
        desc: "File with validator key to be imported (in hex form)".}: Option[ValidatorKeyPath]

      key* {.
        desc: "Validator key to be imported (in hex form)".}: Option[string]

    of updateTestnet:
      discard

proc defaultDataDir*(conf: BeaconNodeConf): string =
  if conf.network == ephemeralNetwork:
    getCurrentDir() / "beacon-node-cache"

  else:
    let dataDir = when defined(windows):
      "AppData" / "Roaming" / "Nimbus"
    elif defined(macosx):
      "Library" / "Application Support" / "Nimbus"
    else:
      ".cache" / "nimbus"

    getHomeDir() / dataDir / "BeaconNode" / $conf.network

proc defaultPort*(conf: BeaconNodeConf): int =
  (if conf.network == testnet0: 9630 else: 9632) + ord(useRLPx)

proc validatorFileBaseName*(validatorIdx: int): string =
  # there can apparently be tops 4M validators so we use 7 digits..
  fmt"v{validatorIdx:07}"

