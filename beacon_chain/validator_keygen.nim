import
  os, ospaths, strutils, strformat,
  chronos, blscurve, nimcrypto, json_serialization, confutils, web3, stint,
  spec/[datatypes, digest, crypto], conf, time, ssz,
  ../tests/testutil

import json_rpc/rpcclient

contract(DepositContract):
  proc deposit(pubkey: Bytes48, withdrawalCredentials: Bytes32, signature: Bytes96)

proc writeTextFile(filename: string, contents: string) =
  writeFile(filename, contents)
  echo "Wrote ", filename

proc writeFile(filename: string, value: auto) =
  Json.saveFile(filename, value, pretty = true)
  echo "Wrote ", filename


proc ethToWei(eth: UInt256): UInt256 =
  eth * 1000000000000000000.u256

import web3/stintjson, json

proc main(totalValidators: int, outputDir: string, generateFakeKeys: bool, depositWeb3Url, depositContractAddress: string) {.async.} =
  var web3: Web3
  var contractAddress: Address
  var eth1Addresses: seq[Address]

  if depositWeb3Url.len > 0:
    let provider = newRpcWebSocketClient()
    await provider.connect(depositWeb3Url)
    web3 = newWeb3(provider)
    contractAddress = Address.fromHex(depositContractAddress)
    eth1Addresses = await web3.provider.eth_accounts()

  for i in 0 ..< totalValidators:
    let
      v = validatorFileBaseName(i)
      depositFn = outputDir / v & ".deposit.json"
      privKeyFn = outputDir / v & ".privkey"

    if existsFile(depositFn) and existsFile(privKeyFn):
      continue

    let
      privKey = if generateFakeKeys: makeFakeValidatorPrivKey(i)
                else: ValidatorPrivKey.random
      pubKey = privKey.pubKey()

    let
      withdrawalCredentials = makeFakeHash(i)
      domain = 3'u64

    var
      dp = Deposit(
        data: DepositData(
          amount: MAX_EFFECTIVE_BALANCE,
          pubkey: pubKey,
          withdrawal_credentials: withdrawalCredentials))

    dp.data.signature =
      bls_sign(privkey, signing_root(dp.data).data,
               domain)

    writeTextFile(privKeyFn, $privKey)
    writeFile(depositFn, dp)

    if not web3.isNil:
      let depositContract = web3.contractSender(DepositContract, contractAddress, eth1Addresses[i])
      depositContract.value = 32.u256.ethToWei
      let tx = await depositContract.deposit(Bytes48(pubKey.getBytes()), Bytes32(withdrawalCredentials.data), Bytes96(dp.data.signature.getBytes()))

  if generateFakeKeys:
    echo "Keys generated by this tool are only for testing!"


cli do (totalValidators: int = 125000,
        outputDir: string = "validators",
        generateFakeKeys = false,
        depositWeb3Url: string = "",
        depositContractAddress: string = ""):

  waitFor main(totalValidators, outputDir, generateFakeKeys, depositWeb3Url, depositContractAddress)
